{"traceEvents":[{"ph":"M","pid":15853,"tid":15853,"name":"process_name","args":{"name":"MainProcess"}},{"ph":"M","pid":15853,"tid":15860,"name":"thread_name","args":{"name":"Thread-4"}},{"ph":"M","pid":15853,"tid":15859,"name":"thread_name","args":{"name":"Thread-3"}},{"ph":"M","pid":15853,"tid":15858,"name":"thread_name","args":{"name":"Thread-2"}},{"ph":"M","pid":15853,"tid":15857,"name":"thread_name","args":{"name":"Thread-1"}},{"ph":"M","pid":15853,"tid":15853,"name":"thread_name","args":{"name":"MainThread"}},{"pid":15853,"tid":15853,"ts":14607090375.889,"dur":1.3,"name":"_newname (/usr/lib/python3.6/threading.py:727)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090378.389,"dur":0.2,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090378.289,"dur":0.6,"name":"current_thread (/usr/lib/python3.6/threading.py:1230)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090379.489,"dur":0.3,"name":"daemon (/usr/lib/python3.6/threading.py:1120)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090381.689,"dur":0.2,"name":"_thread.allocate_lock","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090382.489,"dur":4.4,"name":"__init__ (/usr/lib/python3.6/threading.py:215)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090381.489,"dur":5.8,"name":"__init__ (/usr/lib/python3.6/threading.py:498)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090390.389,"dur":0.3,"name":"set.add","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090389.189,"dur":1.6,"name":"add (/usr/lib/python3.6/_weakrefset.py:81)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090374.289,"dur":16.52,"name":"__init__ (/usr/lib/python3.6/threading.py:757)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090392.089,"dur":0.4,"name":"_newname (/usr/lib/python3.6/threading.py:727)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090393.089,"dur":0.1,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090392.989,"dur":0.3,"name":"current_thread (/usr/lib/python3.6/threading.py:1230)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090393.489,"dur":0.1,"name":"daemon (/usr/lib/python3.6/threading.py:1120)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090394.089,"dur":0.1,"name":"_thread.allocate_lock","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090394.389,"dur":1.5,"name":"__init__ (/usr/lib/python3.6/threading.py:215)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090393.989,"dur":2.2,"name":"__init__ (/usr/lib/python3.6/threading.py:498)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090397.089,"dur":0.1,"name":"set.add","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090396.789,"dur":0.5,"name":"add (/usr/lib/python3.6/_weakrefset.py:81)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090391.289,"dur":6.1,"name":"__init__ (/usr/lib/python3.6/threading.py:757)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090398.189,"dur":0.2,"name":"_newname (/usr/lib/python3.6/threading.py:727)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090398.689,"dur":0.1,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090398.589,"dur":0.3,"name":"current_thread (/usr/lib/python3.6/threading.py:1230)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090398.989,"dur":0.1,"name":"daemon (/usr/lib/python3.6/threading.py:1120)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090399.409,"dur":0.18,"name":"_thread.allocate_lock","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090399.689,"dur":1.4,"name":"__init__ (/usr/lib/python3.6/threading.py:215)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090399.389,"dur":1.9,"name":"__init__ (/usr/lib/python3.6/threading.py:498)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090402.089,"dur":0.02,"name":"set.add","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090401.789,"dur":0.4,"name":"add (/usr/lib/python3.6/_weakrefset.py:81)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090397.789,"dur":4.5,"name":"__init__ (/usr/lib/python3.6/threading.py:757)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090402.889,"dur":0.2,"name":"_newname (/usr/lib/python3.6/threading.py:727)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090403.389,"dur":0.1,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090403.289,"dur":0.3,"name":"current_thread (/usr/lib/python3.6/threading.py:1230)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090403.689,"dur":0.1,"name":"daemon (/usr/lib/python3.6/threading.py:1120)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090404.009,"dur":0.18,"name":"_thread.allocate_lock","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090404.289,"dur":1.3,"name":"__init__ (/usr/lib/python3.6/threading.py:215)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090403.989,"dur":1.7,"name":"__init__ (/usr/lib/python3.6/threading.py:498)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090406.389,"dur":0.2,"name":"set.add","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090406.089,"dur":0.6,"name":"add (/usr/lib/python3.6/_weakrefset.py:81)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090402.589,"dur":4.12,"name":"__init__ (/usr/lib/python3.6/threading.py:757)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090407.689,"dur":0.1,"name":"is_set (/usr/lib/python3.6/threading.py:506)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090409.989,"dur":60.2,"name":"_thread.start_new_thread","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090473.389,"dur":0.4,"name":"_thread.lock.__enter__","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090472.589,"dur":1.4,"name":"__enter__ (/usr/lib/python3.6/threading.py:239)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090475.689,"dur":0.5,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090475.389,"dur":0.9,"name":"_is_owned (/usr/lib/python3.6/threading.py:254)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090476.589,"dur":0.2,"name":"_thread.allocate_lock","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090478.589,"dur":0.1,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090479.389,"dur":0.2,"name":"collections.deque.append","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090480.189,"dur":0.1,"name":"_thread.lock.release","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090479.989,"dur":0.32,"name":"_release_save (/usr/lib/python3.6/threading.py:248)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090480.589,"dur":125.0,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090609.289,"dur":0.5,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090608.489,"dur":1.5,"name":"_acquire_restore (/usr/lib/python3.6/threading.py:251)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090474.989,"dur":135.3,"name":"wait (/usr/lib/python3.6/threading.py:263)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090611.889,"dur":0.1,"name":"_thread.lock.__exit__","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090611.589,"dur":0.5,"name":"__exit__ (/usr/lib/python3.6/threading.py:242)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090471.689,"dur":140.7,"name":"wait (/usr/lib/python3.6/threading.py:533)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090407.189,"dur":205.5,"name":"start (/usr/lib/python3.6/threading.py:828)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090614.289,"dur":0.2,"name":"is_set (/usr/lib/python3.6/threading.py:506)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090615.989,"dur":114.3,"name":"_thread.start_new_thread","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090732.589,"dur":0.4,"name":"_thread.lock.__enter__","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090732.189,"dur":0.9,"name":"__enter__ (/usr/lib/python3.6/threading.py:239)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090733.989,"dur":0.5,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090733.889,"dur":0.7,"name":"_is_owned (/usr/lib/python3.6/threading.py:254)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090734.789,"dur":0.3,"name":"_thread.allocate_lock","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090735.189,"dur":0.1,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090735.589,"dur":0.1,"name":"collections.deque.append","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090736.089,"dur":0.1,"name":"_thread.lock.release","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090735.889,"dur":0.4,"name":"_release_save (/usr/lib/python3.6/threading.py:248)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090736.589,"dur":100.6,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090839.589,"dur":0.4,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090838.989,"dur":1.1,"name":"_acquire_restore (/usr/lib/python3.6/threading.py:251)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090733.689,"dur":106.7,"name":"wait (/usr/lib/python3.6/threading.py:263)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090841.889,"dur":0.1,"name":"_thread.lock.__exit__","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090841.689,"dur":0.4,"name":"__exit__ (/usr/lib/python3.6/threading.py:242)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090731.489,"dur":110.9,"name":"wait (/usr/lib/python3.6/threading.py:533)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090613.689,"dur":228.9,"name":"start (/usr/lib/python3.6/threading.py:828)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090843.889,"dur":0.1,"name":"is_set (/usr/lib/python3.6/threading.py:506)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090845.389,"dur":65.7,"name":"_thread.start_new_thread","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090913.389,"dur":0.4,"name":"_thread.lock.__enter__","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090912.989,"dur":0.9,"name":"__enter__ (/usr/lib/python3.6/threading.py:239)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090932.889,"dur":0.6,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090932.689,"dur":0.9,"name":"_is_owned (/usr/lib/python3.6/threading.py:254)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090933.689,"dur":0.3,"name":"_thread.allocate_lock","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090934.089,"dur":0.1,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090934.589,"dur":0.2,"name":"collections.deque.append","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090935.189,"dur":0.1,"name":"_thread.lock.release","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090934.989,"dur":0.4,"name":"_release_save (/usr/lib/python3.6/threading.py:248)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090935.589,"dur":134.0,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091071.689,"dur":0.5,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091071.189,"dur":1.2,"name":"_acquire_restore (/usr/lib/python3.6/threading.py:251)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090932.489,"dur":140.2,"name":"wait (/usr/lib/python3.6/threading.py:263)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091074.289,"dur":2.7,"name":"_thread.lock.__exit__","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091073.989,"dur":3.2,"name":"__exit__ (/usr/lib/python3.6/threading.py:242)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090912.189,"dur":165.3,"name":"wait (/usr/lib/python3.6/threading.py:533)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607090843.389,"dur":234.4,"name":"start (/usr/lib/python3.6/threading.py:828)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091078.989,"dur":0.2,"name":"is_set (/usr/lib/python3.6/threading.py:506)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091080.689,"dur":62.9,"name":"_thread.start_new_thread","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091145.789,"dur":0.4,"name":"_thread.lock.__enter__","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091145.489,"dur":0.9,"name":"__enter__ (/usr/lib/python3.6/threading.py:239)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091147.389,"dur":0.4,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091147.189,"dur":0.8,"name":"_is_owned (/usr/lib/python3.6/threading.py:254)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091148.089,"dur":0.3,"name":"_thread.allocate_lock","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091148.489,"dur":0.1,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091148.889,"dur":0.2,"name":"collections.deque.append","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091149.389,"dur":0.1,"name":"_thread.lock.release","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091149.189,"dur":0.4,"name":"_release_save (/usr/lib/python3.6/threading.py:248)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607090573.689,"dur":596.9,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091020.689,"dur":428.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091319.089,"dur":191.4,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607091173.089,"dur":443.4,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091451.389,"dur":190.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091513.389,"dur":256.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607090808.789,"dur":983.0,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091644.089,"dur":209.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091771.989,"dur":89.8,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091149.789,"dur":717.1,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091868.989,"dur":0.5,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091868.589,"dur":1.1,"name":"_acquire_restore (/usr/lib/python3.6/threading.py:251)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091146.889,"dur":723.0,"name":"wait (/usr/lib/python3.6/threading.py:263)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091871.589,"dur":0.1,"name":"_thread.lock.__exit__","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091871.289,"dur":0.5,"name":"__exit__ (/usr/lib/python3.6/threading.py:242)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091144.789,"dur":727.3,"name":"wait (/usr/lib/python3.6/threading.py:533)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091078.489,"dur":793.8,"name":"start (/usr/lib/python3.6/threading.py:828)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091875.689,"dur":0.2,"name":"is_set (/usr/lib/python3.6/threading.py:506)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091876.489,"dur":0.3,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091876.189,"dur":1.1,"name":"current_thread (/usr/lib/python3.6/threading.py:1230)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607091618.989,"dur":267.9,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091864.389,"dur":91.0,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091855.689,"dur":112.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607091797.389,"dur":198.8,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607091889.589,"dur":112.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091957.789,"dur":99.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091970.889,"dur":130.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607091998.689,"dur":114.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092004.389,"dur":125.9,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092059.389,"dur":93.8,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092154.589,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092155.389,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092058.389,"dur":99.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092157.989,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091956.789,"dur":201.3,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092106.789,"dur":104.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092212.989,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092213.689,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092105.689,"dur":108.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092214.089,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091969.789,"dur":244.42,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092115.389,"dur":123.5,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092132.789,"dur":136.9,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092270.589,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092271.289,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092131.789,"dur":139.7,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092271.689,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092003.289,"dur":268.52,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092170.489,"dur":115.6,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092287.489,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092288.189,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092158.289,"dur":130.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091863.289,"dur":425.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092214.889,"dur":91.6,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092307.789,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092308.489,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092214.389,"dur":94.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091854.689,"dur":454.3,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092241.489,"dur":107.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092272.489,"dur":104.8,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092378.689,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092379.289,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092272.089,"dur":107.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607091888.589,"dur":491.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092289.389,"dur":129.3,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092309.689,"dur":114.3,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092380.489,"dur":73.8,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092351.089,"dur":111.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092463.689,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092464.389,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092350.089,"dur":114.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092464.889,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092240.389,"dur":224.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092420.989,"dur":76.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092498.389,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092499.089,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092420.189,"dur":79.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092499.589,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092288.789,"dur":213.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091770.889,"dur":731.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092426.089,"dur":80.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092507.689,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092508.389,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092425.289,"dur":83.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092508.989,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092309.189,"dur":199.9,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091642.989,"dur":866.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092456.489,"dur":106.8,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092564.689,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092565.389,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092455.689,"dur":109.9,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092565.889,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092379.989,"dur":186.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607091617.989,"dur":948.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092465.689,"dur":111.5,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092578.689,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092579.389,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092465.189,"dur":114.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092114.289,"dur":465.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092502.989,"dur":116.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092509.989,"dur":125.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092580.489,"dur":76.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092566.889,"dur":120.6,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092621.489,"dur":107.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092637.389,"dur":102.9,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092658.689,"dur":111.5,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092771.589,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092772.289,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092657.889,"dur":114.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092772.789,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092579.989,"dur":192.9,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607091997.689,"dur":775.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092689.689,"dur":94.9,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092730.889,"dur":83.5,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092815.689,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092816.389,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092730.089,"dur":86.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092816.889,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092620.589,"dur":196.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092742.489,"dur":80.0,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092823.889,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092824.489,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092741.689,"dur":83.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092824.989,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092636.589,"dur":188.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092773.689,"dur":108.8,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092786.889,"dur":105.4,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092893.689,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092894.389,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092786.089,"dur":108.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092894.889,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092688.889,"dur":206.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092817.689,"dur":99.5,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092918.489,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092919.089,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092817.189,"dur":102.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092502.489,"dur":417.0,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091512.089,"dur":1407.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092840.489,"dur":86.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092928.489,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092929.189,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092839.589,"dur":89.9,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092509.389,"dur":420.3,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091450.289,"dur":1479.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092884.689,"dur":94.9,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092920.289,"dur":81.4,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092895.789,"dur":173.0,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093070.389,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093071.089,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092895.289,"dur":176.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607092566.289,"dur":505.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607091172.089,"dur":1899.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092981.789,"dur":107.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093090.989,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093091.689,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092980.989,"dur":111.0,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093092.189,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092883.889,"dur":208.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092930.389,"dur":188.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093003.889,"dur":159.6,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093072.389,"dur":98.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093093.089,"dur":111.8,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093206.289,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093206.989,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093092.589,"dur":114.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607092773.189,"dur":434.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607091796.089,"dur":1411.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093121.489,"dur":126.6,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093165.489,"dur":113.4,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093173.289,"dur":110.4,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093208.189,"dur":115.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093250.389,"dur":94.0,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093285.789,"dur":72.5,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093281.089,"dur":105.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093387.689,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093388.289,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093280.289,"dur":108.3,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093388.789,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093164.789,"dur":224.12,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093346.889,"dur":74.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093422.389,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093422.989,"dur":0.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093346.089,"dur":77.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093423.489,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093249.589,"dur":174.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093325.589,"dur":107.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093360.289,"dur":99.3,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093460.989,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093461.689,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093359.589,"dur":102.3,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093462.089,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093285.089,"dur":177.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093389.589,"dur":114.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093505.189,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093505.889,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093389.089,"dur":117.0,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093003.189,"dur":503.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093424.289,"dur":112.5,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093538.189,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093538.889,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093423.789,"dur":115.3,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093120.689,"dur":418.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093434.989,"dur":111.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093462.789,"dur":117.1,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093581.289,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093581.989,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093462.389,"dur":119.8,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093172.489,"dur":409.9,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093506.889,"dur":105.0,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093548.989,"dur":73.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093623.589,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093624.189,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093548.189,"dur":76.3,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093624.689,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093434.189,"dur":190.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093539.889,"dur":107.5,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093613.989,"dur":74.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093689.389,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093692.489,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093613.289,"dur":79.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093692.889,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093506.389,"dur":186.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607092919.689,"dur":773.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091318.689,"dur":2374.52,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607091317.989,"dur":2375.5,"name":"run (example/src/multithread.py:15)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15860,"ts":14607093695.689,"dur":0.2,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093583.089,"dur":117.7,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093625.389,"dur":112.6,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093739.389,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093740.089,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093624.989,"dur":115.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093324.789,"dur":415.7,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093649.489,"dur":93.3,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093744.289,"dur":0.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093744.889,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093648.789,"dur":96.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093745.389,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093539.389,"dur":206.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607092929.989,"dur":815.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091020.289,"dur":2725.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607091019.689,"dur":2726.2,"name":"run (example/src/multithread.py:15)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15859,"ts":14607093747.589,"dur":0.2,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093702.989,"dur":74.2,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093778.389,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093779.089,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093702.189,"dur":77.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093779.489,"dur":0.02,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093582.589,"dur":197.0,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093071.889,"dur":707.8,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607090572.789,"dur":3207.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607090570.589,"dur":3209.5,"name":"run (example/src/multithread.py:15)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15857,"ts":14607093781.989,"dur":0.2,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091878.589,"dur":1958.2,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093837.789,"dur":0.1,"name":"_thread.lock.release","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093840.789,"dur":0.2,"name":"_thread.lock.locked","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093839.589,"dur":2.1,"name":"_stop (/usr/lib/python3.6/threading.py:966)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091878.189,"dur":1963.6,"name":"_wait_for_tstate_lock (/usr/lib/python3.6/threading.py:1062)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607091875.089,"dur":1967.4,"name":"join (/usr/lib/python3.6/threading.py:1024)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093844.289,"dur":0.2,"name":"is_set (/usr/lib/python3.6/threading.py:506)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093844.989,"dur":0.2,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093844.789,"dur":0.9,"name":"current_thread (/usr/lib/python3.6/threading.py:1230)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093741.189,"dur":112.9,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093856.289,"dur":97.0,"name":"time.sleep","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093954.589,"dur":0.5,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093955.189,"dur":0.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093855.489,"dur":102.4,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093958.089,"dur":0.1,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093740.689,"dur":217.6,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093207.689,"dur":750.7,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607090808.289,"dur":3150.2,"name":"fib (example/src/multithread.py:7)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607090805.889,"dur":3152.8,"name":"run (example/src/multithread.py:15)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15858,"ts":14607093960.289,"dur":0.3,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093846.289,"dur":175.4,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094022.889,"dur":0.3,"name":"_thread.lock.release","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094024.889,"dur":0.1,"name":"_thread.lock.locked","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094024.389,"dur":1.2,"name":"_stop (/usr/lib/python3.6/threading.py:966)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093845.989,"dur":179.7,"name":"_wait_for_tstate_lock (/usr/lib/python3.6/threading.py:1062)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607093843.689,"dur":182.5,"name":"join (/usr/lib/python3.6/threading.py:1024)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094027.789,"dur":0.2,"name":"is_set (/usr/lib/python3.6/threading.py:506)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094028.489,"dur":0.3,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094028.189,"dur":1.1,"name":"current_thread (/usr/lib/python3.6/threading.py:1230)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094051.989,"dur":1.0,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094053.089,"dur":0.1,"name":"_thread.lock.release","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094053.389,"dur":0.02,"name":"_thread.lock.locked","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094053.289,"dur":0.3,"name":"_stop (/usr/lib/python3.6/threading.py:966)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094051.889,"dur":1.72,"name":"_wait_for_tstate_lock (/usr/lib/python3.6/threading.py:1062)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094027.389,"dur":26.4,"name":"join (/usr/lib/python3.6/threading.py:1024)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094054.189,"dur":0.02,"name":"is_set (/usr/lib/python3.6/threading.py:506)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094054.389,"dur":0.1,"name":"_thread.get_ident","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094054.289,"dur":0.22,"name":"current_thread (/usr/lib/python3.6/threading.py:1230)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094054.789,"dur":0.2,"name":"_thread.lock.acquire","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094055.009,"dur":0.08,"name":"_thread.lock.release","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094055.289,"dur":0.02,"name":"_thread.lock.locked","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094055.189,"dur":0.2,"name":"_stop (/usr/lib/python3.6/threading.py:966)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094054.689,"dur":0.8,"name":"_wait_for_tstate_lock (/usr/lib/python3.6/threading.py:1062)","ph":"X","cat":"FEE"},{"pid":15853,"tid":15853,"ts":14607094053.989,"dur":1.6,"name":"join (/usr/lib/python3.6/threading.py:1024)","ph":"X","cat":"FEE"}],"viztracer_metadata":{"version":"0.13.1"},"displayTimeUnit":"us","file_info":{"files":{"/usr/lib/python3.6/threading.py":["\"\"\"Thread module emulating a subset of Java's threading model.\"\"\"\n\nimport sys as _sys\nimport _thread\n\nfrom time import monotonic as _time\nfrom traceback import format_exc as _format_exc\nfrom _weakrefset import WeakSet\nfrom itertools import islice as _islice, count as _count\ntry:\n    from _collections import deque as _deque\nexcept ImportError:\n    from collections import deque as _deque\n\n# Note regarding PEP 8 compliant names\n#  This threading model was originally inspired by Java, and inherited\n# the convention of camelCase function and method names from that\n# language. Those original names are not in any imminent danger of\n# being deprecated (even for Py3k),so this module provides them as an\n# alias for the PEP 8 compliant names\n# Note that using the new PEP 8 compliant names facilitates substitution\n# with the multiprocessing module, which doesn't provide the old\n# Java inspired names.\n\n__all__ = ['get_ident', 'active_count', 'Condition', 'current_thread',\n           'enumerate', 'main_thread', 'TIMEOUT_MAX',\n           'Event', 'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',\n           'Barrier', 'BrokenBarrierError', 'Timer', 'ThreadError',\n           'setprofile', 'settrace', 'local', 'stack_size']\n\n# Rename some stuff so \"from threading import *\" is safe\n_start_new_thread = _thread.start_new_thread\n_allocate_lock = _thread.allocate_lock\n_set_sentinel = _thread._set_sentinel\nget_ident = _thread.get_ident\nThreadError = _thread.error\ntry:\n    _CRLock = _thread.RLock\nexcept AttributeError:\n    _CRLock = None\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\ndel _thread\n\n\n# Support for profile and trace hooks\n\n_profile_hook = None\n_trace_hook = None\n\ndef setprofile(func):\n    \"\"\"Set a profile function for all threads started from the threading module.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n\n    \"\"\"\n    global _profile_hook\n    _profile_hook = func\n\ndef settrace(func):\n    \"\"\"Set a trace function for all threads started from the threading module.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n\n    \"\"\"\n    global _trace_hook\n    _trace_hook = func\n\n# Synchronization classes\n\nLock = _allocate_lock\n\ndef RLock(*args, **kwargs):\n    \"\"\"Factory function that returns a new reentrant lock.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it again\n    without blocking; the thread must release it once for each time it has\n    acquired it.\n\n    \"\"\"\n    if _CRLock is None:\n        return _PyRLock(*args, **kwargs)\n    return _CRLock(*args, **kwargs)\n\nclass _RLock:\n    \"\"\"This class implements reentrant lock objects.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it\n    again without blocking; the thread must release it once for each time it\n    has acquired it.\n\n    \"\"\"\n\n    def __init__(self):\n        self._block = _allocate_lock()\n        self._owner = None\n        self._count = 0\n\n    def __repr__(self):\n        owner = self._owner\n        try:\n            owner = _active[owner].name\n        except KeyError:\n            pass\n        return \"<%s %s.%s object owner=%r count=%d at %s>\" % (\n            \"locked\" if self._block.locked() else \"unlocked\",\n            self.__class__.__module__,\n            self.__class__.__qualname__,\n            owner,\n            self._count,\n            hex(id(self))\n        )\n\n    def acquire(self, blocking=True, timeout=-1):\n        \"\"\"Acquire a lock, blocking or non-blocking.\n\n        When invoked without arguments: if this thread already owns the lock,\n        increment the recursion level by one, and return immediately. Otherwise,\n        if another thread owns the lock, block until the lock is unlocked. Once\n        the lock is unlocked (not owned by any thread), then grab ownership, set\n        the recursion level to one, and return. If more than one thread is\n        blocked waiting until the lock is unlocked, only one at a time will be\n        able to grab ownership of the lock. There is no return value in this\n        case.\n\n        When invoked with the blocking argument set to true, do the same thing\n        as when called without arguments, and return true.\n\n        When invoked with the blocking argument set to false, do not block. If a\n        call without an argument would block, return false immediately;\n        otherwise, do the same thing as when called without arguments, and\n        return true.\n\n        When invoked with the floating-point timeout argument set to a positive\n        value, block for at most the number of seconds specified by timeout\n        and as long as the lock cannot be acquired.  Return true if the lock has\n        been acquired, false if the timeout has elapsed.\n\n        \"\"\"\n        me = get_ident()\n        if self._owner == me:\n            self._count += 1\n            return 1\n        rc = self._block.acquire(blocking, timeout)\n        if rc:\n            self._owner = me\n            self._count = 1\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a lock, decrementing the recursion level.\n\n        If after the decrement it is zero, reset the lock to unlocked (not owned\n        by any thread), and if any other threads are blocked waiting for the\n        lock to become unlocked, allow exactly one of them to proceed. If after\n        the decrement the recursion level is still nonzero, the lock remains\n        locked and owned by the calling thread.\n\n        Only call this method when the calling thread owns the lock. A\n        RuntimeError is raised if this method is called when the lock is\n        unlocked.\n\n        There is no return value.\n\n        \"\"\"\n        if self._owner != get_ident():\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        self._count = count = self._count - 1\n        if not count:\n            self._owner = None\n            self._block.release()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n    # Internal methods used by condition variables\n\n    def _acquire_restore(self, state):\n        self._block.acquire()\n        self._count, self._owner = state\n\n    def _release_save(self):\n        if self._count == 0:\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        count = self._count\n        self._count = 0\n        owner = self._owner\n        self._owner = None\n        self._block.release()\n        return (count, owner)\n\n    def _is_owned(self):\n        return self._owner == get_ident()\n\n_PyRLock = _RLock\n\n\nclass Condition:\n    \"\"\"Class that implements a condition variable.\n\n    A condition variable allows one or more threads to wait until they are\n    notified by another thread.\n\n    If the lock argument is given and not None, it must be a Lock or RLock\n    object, and it is used as the underlying lock. Otherwise, a new RLock object\n    is created and used as the underlying lock.\n\n    \"\"\"\n\n    def __init__(self, lock=None):\n        if lock is None:\n            lock = RLock()\n        self._lock = lock\n        # Export the lock's acquire() and release() methods\n        self.acquire = lock.acquire\n        self.release = lock.release\n        # If the lock defines _release_save() and/or _acquire_restore(),\n        # these override the default implementations (which just call\n        # release() and acquire() on the lock).  Ditto for _is_owned().\n        try:\n            self._release_save = lock._release_save\n        except AttributeError:\n            pass\n        try:\n            self._acquire_restore = lock._acquire_restore\n        except AttributeError:\n            pass\n        try:\n            self._is_owned = lock._is_owned\n        except AttributeError:\n            pass\n        self._waiters = _deque()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n    def __repr__(self):\n        return \"<Condition(%s, %d)>\" % (self._lock, len(self._waiters))\n\n    def _release_save(self):\n        self._lock.release()           # No state to save\n\n    def _acquire_restore(self, x):\n        self._lock.acquire()           # Ignore saved state\n\n    def _is_owned(self):\n        # Return True if lock is owned by current_thread.\n        # This method is called only if _lock doesn't have _is_owned().\n        if self._lock.acquire(0):\n            self._lock.release()\n            return False\n        else:\n            return True\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n                waiter.acquire()\n                gotit = True\n            else:\n                if timeout > 0:\n                    gotit = waiter.acquire(True, timeout)\n                else:\n                    gotit = waiter.acquire(False)\n            return gotit\n        finally:\n            self._acquire_restore(saved_state)\n            if not gotit:\n                try:\n                    self._waiters.remove(waiter)\n                except ValueError:\n                    pass\n\n    def wait_for(self, predicate, timeout=None):\n        \"\"\"Wait until a condition evaluates to True.\n\n        predicate should be a callable which result will be interpreted as a\n        boolean value.  A timeout may be provided giving the maximum time to\n        wait.\n\n        \"\"\"\n        endtime = None\n        waittime = timeout\n        result = predicate()\n        while not result:\n            if waittime is not None:\n                if endtime is None:\n                    endtime = _time() + waittime\n                else:\n                    waittime = endtime - _time()\n                    if waittime <= 0:\n                        break\n            self.wait(waittime)\n            result = predicate()\n        return result\n\n    def notify(self, n=1):\n        \"\"\"Wake up one or more threads waiting on this condition, if any.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method wakes up at most n of the threads waiting for the condition\n        variable; it is a no-op if no threads are waiting.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot notify on un-acquired lock\")\n        all_waiters = self._waiters\n        waiters_to_notify = _deque(_islice(all_waiters, n))\n        if not waiters_to_notify:\n            return\n        for waiter in waiters_to_notify:\n            waiter.release()\n            try:\n                all_waiters.remove(waiter)\n            except ValueError:\n                pass\n\n    def notify_all(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        If the calling thread has not acquired the lock when this method\n        is called, a RuntimeError is raised.\n\n        \"\"\"\n        self.notify(len(self._waiters))\n\n    notifyAll = notify_all\n\n\nclass Semaphore:\n    \"\"\"This class implements semaphore objects.\n\n    Semaphores manage a counter representing the number of release() calls minus\n    the number of acquire() calls, plus an initial value. The acquire() method\n    blocks if necessary until it can return without making the counter\n    negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    # After Tim Peters' semaphore class, but not quite the same (no maximum)\n\n    def __init__(self, value=1):\n        if value < 0:\n            raise ValueError(\"semaphore initial value must be >= 0\")\n        self._cond = Condition(Lock())\n        self._value = value\n\n    def acquire(self, blocking=True, timeout=None):\n        \"\"\"Acquire a semaphore, decrementing the internal counter by one.\n\n        When invoked without arguments: if the internal counter is larger than\n        zero on entry, decrement it by one and return immediately. If it is zero\n        on entry, block, waiting until some other thread has called release() to\n        make it larger than zero. This is done with proper interlocking so that\n        if multiple acquire() calls are blocked, release() will wake exactly one\n        of them up. The implementation may pick one at random, so the order in\n        which blocked threads are awakened should not be relied on. There is no\n        return value in this case.\n\n        When invoked with blocking set to true, do the same thing as when called\n        without arguments, and return true.\n\n        When invoked with blocking set to false, do not block. If a call without\n        an argument would block, return false immediately; otherwise, do the\n        same thing as when called without arguments, and return true.\n\n        When invoked with a timeout other than None, it will block for at\n        most timeout seconds.  If acquire does not complete successfully in\n        that interval, return false.  Return true otherwise.\n\n        \"\"\"\n        if not blocking and timeout is not None:\n            raise ValueError(\"can't specify timeout for non-blocking acquire\")\n        rc = False\n        endtime = None\n        with self._cond:\n            while self._value == 0:\n                if not blocking:\n                    break\n                if timeout is not None:\n                    if endtime is None:\n                        endtime = _time() + timeout\n                    else:\n                        timeout = endtime - _time()\n                        if timeout <= 0:\n                            break\n                self._cond.wait(timeout)\n            else:\n                self._value -= 1\n                rc = True\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a semaphore, incrementing the internal counter by one.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        \"\"\"\n        with self._cond:\n            self._value += 1\n            self._cond.notify()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\nclass BoundedSemaphore(Semaphore):\n    \"\"\"Implements a bounded semaphore.\n\n    A bounded semaphore checks to make sure its current value doesn't exceed its\n    initial value. If it does, ValueError is raised. In most situations\n    semaphores are used to guard resources with limited capacity.\n\n    If the semaphore is released too many times it's a sign of a bug. If not\n    given, value defaults to 1.\n\n    Like regular semaphores, bounded semaphores manage a counter representing\n    the number of release() calls minus the number of acquire() calls, plus an\n    initial value. The acquire() method blocks if necessary until it can return\n    without making the counter negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    def __init__(self, value=1):\n        Semaphore.__init__(self, value)\n        self._initial_value = value\n\n    def release(self):\n        \"\"\"Release a semaphore, incrementing the internal counter by one.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        If the number of releases exceeds the number of acquires,\n        raise a ValueError.\n\n        \"\"\"\n        with self._cond:\n            if self._value >= self._initial_value:\n                raise ValueError(\"Semaphore released too many times\")\n            self._value += 1\n            self._cond.notify()\n\n\nclass Event:\n    \"\"\"Class implementing event objects.\n\n    Events manage a flag that can be set to true with the set() method and reset\n    to false with the clear() method. The wait() method blocks until the flag is\n    true.  The flag is initially false.\n\n    \"\"\"\n\n    # After Tim Peters' event class (without is_posted())\n\n    def __init__(self):\n        self._cond = Condition(Lock())\n        self._flag = False\n\n    def _reset_internal_locks(self):\n        # private!  called by Thread._reset_internal_locks by _after_fork()\n        self._cond.__init__(Lock())\n\n    def is_set(self):\n        \"\"\"Return true if and only if the internal flag is true.\"\"\"\n        return self._flag\n\n    isSet = is_set\n\n    def set(self):\n        \"\"\"Set the internal flag to true.\n\n        All threads waiting for it to become true are awakened. Threads\n        that call wait() once the flag is true will not block at all.\n\n        \"\"\"\n        with self._cond:\n            self._flag = True\n            self._cond.notify_all()\n\n    def clear(self):\n        \"\"\"Reset the internal flag to false.\n\n        Subsequently, threads calling wait() will block until set() is called to\n        set the internal flag to true again.\n\n        \"\"\"\n        with self._cond:\n            self._flag = False\n\n    def wait(self, timeout=None):\n        \"\"\"Block until the internal flag is true.\n\n        If the internal flag is true on entry, return immediately. Otherwise,\n        block until another thread calls set() to set the flag to true, or until\n        the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        This method returns the internal flag on exit, so it will always return\n        True except if a timeout is given and the operation times out.\n\n        \"\"\"\n        with self._cond:\n            signaled = self._flag\n            if not signaled:\n                signaled = self._cond.wait(timeout)\n            return signaled\n\n\n# A barrier class.  Inspired in part by the pthread_barrier_* api and\n# the CyclicBarrier class from Java.  See\n# http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and\n# http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/\n#        CyclicBarrier.html\n# for information.\n# We maintain two main states, 'filling' and 'draining' enabling the barrier\n# to be cyclic.  Threads are not allowed into it until it has fully drained\n# since the previous cycle.  In addition, a 'resetting' state exists which is\n# similar to 'draining' except that threads leave with a BrokenBarrierError,\n# and a 'broken' state in which all threads get the exception.\nclass Barrier:\n    \"\"\"Implements a Barrier.\n\n    Useful for synchronizing a fixed number of threads at known synchronization\n    points.  Threads block on 'wait()' and are simultaneously once they have all\n    made that call.\n\n    \"\"\"\n\n    def __init__(self, parties, action=None, timeout=None):\n        \"\"\"Create a barrier, initialised to 'parties' threads.\n\n        'action' is a callable which, when supplied, will be called by one of\n        the threads after they have all entered the barrier and just prior to\n        releasing them all. If a 'timeout' is provided, it is uses as the\n        default for all subsequent 'wait()' calls.\n\n        \"\"\"\n        self._cond = Condition(Lock())\n        self._action = action\n        self._timeout = timeout\n        self._parties = parties\n        self._state = 0 #0 filling, 1, draining, -1 resetting, -2 broken\n        self._count = 0\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for the barrier.\n\n        When the specified number of threads have started waiting, they are all\n        simultaneously awoken. If an 'action' was provided for the barrier, one\n        of the threads will have executed that callback prior to returning.\n        Returns an individual index number from 0 to 'parties-1'.\n\n        \"\"\"\n        if timeout is None:\n            timeout = self._timeout\n        with self._cond:\n            self._enter() # Block while the barrier drains.\n            index = self._count\n            self._count += 1\n            try:\n                if index + 1 == self._parties:\n                    # We release the barrier\n                    self._release()\n                else:\n                    # We wait until someone releases us\n                    self._wait(timeout)\n                return index\n            finally:\n                self._count -= 1\n                # Wake up any threads waiting for barrier to drain.\n                self._exit()\n\n    # Block until the barrier is ready for us, or raise an exception\n    # if it is broken.\n    def _enter(self):\n        while self._state in (-1, 1):\n            # It is draining or resetting, wait until done\n            self._cond.wait()\n        #see if the barrier is in a broken state\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 0\n\n    # Optionally run the 'action' and release the threads waiting\n    # in the barrier.\n    def _release(self):\n        try:\n            if self._action:\n                self._action()\n            # enter draining state\n            self._state = 1\n            self._cond.notify_all()\n        except:\n            #an exception during the _action handler.  Break and reraise\n            self._break()\n            raise\n\n    # Wait in the barrier until we are released.  Raise an exception\n    # if the barrier is reset or broken.\n    def _wait(self, timeout):\n        if not self._cond.wait_for(lambda : self._state != 0, timeout):\n            #timed out.  Break the barrier\n            self._break()\n            raise BrokenBarrierError\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 1\n\n    # If we are the last thread to exit the barrier, signal any threads\n    # waiting for the barrier to drain.\n    def _exit(self):\n        if self._count == 0:\n            if self._state in (-1, 1):\n                #resetting or draining\n                self._state = 0\n                self._cond.notify_all()\n\n    def reset(self):\n        \"\"\"Reset the barrier to the initial state.\n\n        Any threads currently waiting will get the BrokenBarrier exception\n        raised.\n\n        \"\"\"\n        with self._cond:\n            if self._count > 0:\n                if self._state == 0:\n                    #reset the barrier, waking up threads\n                    self._state = -1\n                elif self._state == -2:\n                    #was broken, set it to reset state\n                    #which clears when the last thread exits\n                    self._state = -1\n            else:\n                self._state = 0\n            self._cond.notify_all()\n\n    def abort(self):\n        \"\"\"Place the barrier into a 'broken' state.\n\n        Useful in case of error.  Any currently waiting threads and threads\n        attempting to 'wait()' will have BrokenBarrierError raised.\n\n        \"\"\"\n        with self._cond:\n            self._break()\n\n    def _break(self):\n        # An internal error was detected.  The barrier is set to\n        # a broken state all parties awakened.\n        self._state = -2\n        self._cond.notify_all()\n\n    @property\n    def parties(self):\n        \"\"\"Return the number of threads required to trip the barrier.\"\"\"\n        return self._parties\n\n    @property\n    def n_waiting(self):\n        \"\"\"Return the number of threads currently waiting at the barrier.\"\"\"\n        # We don't need synchronization here since this is an ephemeral result\n        # anyway.  It returns the correct value in the steady state.\n        if self._state == 0:\n            return self._count\n        return 0\n\n    @property\n    def broken(self):\n        \"\"\"Return True if the barrier is in a broken state.\"\"\"\n        return self._state == -2\n\n# exception raised by the Barrier class\nclass BrokenBarrierError(RuntimeError):\n    pass\n\n\n# Helper to generate new thread names\n_counter = _count().__next__\n_counter() # Consume 0 so first non-main thread has id 1.\ndef _newname(template=\"Thread-%d\"):\n    return template % _counter()\n\n# Active thread administration\n_active_limbo_lock = _allocate_lock()\n_active = {}    # maps thread id to Thread object\n_limbo = {}\n_dangling = WeakSet()\n\n# Main class for threads\n\nclass Thread:\n    \"\"\"A class that represents a thread of control.\n\n    This class can be safely subclassed in a limited fashion. There are two ways\n    to specify the activity: by passing a callable object to the constructor, or\n    by overriding the run() method in a subclass.\n\n    \"\"\"\n\n    _initialized = False\n    # Need to store a reference to sys.exc_info for printing\n    # out exceptions when a thread tries to use a global var. during interp.\n    # shutdown and thus raises an exception about trying to perform some\n    # operation on/with a NoneType\n    _exc_info = _sys.exc_info\n    # Keep sys.exc_clear too to clear the exception just before\n    # allowing .join() to return.\n    #XXX __exc_clear = _sys.exc_clear\n\n    def __init__(self, group=None, target=None, name=None,\n                 args=(), kwargs=None, *, daemon=None):\n        \"\"\"This constructor should always be called with keyword arguments. Arguments are:\n\n        *group* should be None; reserved for future extension when a ThreadGroup\n        class is implemented.\n\n        *target* is the callable object to be invoked by the run()\n        method. Defaults to None, meaning nothing is called.\n\n        *name* is the thread name. By default, a unique name is constructed of\n        the form \"Thread-N\" where N is a small decimal number.\n\n        *args* is the argument tuple for the target invocation. Defaults to ().\n\n        *kwargs* is a dictionary of keyword arguments for the target\n        invocation. Defaults to {}.\n\n        If a subclass overrides the constructor, it must make sure to invoke\n        the base class constructor (Thread.__init__()) before doing anything\n        else to the thread.\n\n        \"\"\"\n        assert group is None, \"group argument must be None for now\"\n        if kwargs is None:\n            kwargs = {}\n        self._target = target\n        self._name = str(name or _newname())\n        self._args = args\n        self._kwargs = kwargs\n        if daemon is not None:\n            self._daemonic = daemon\n        else:\n            self._daemonic = current_thread().daemon\n        self._ident = None\n        self._tstate_lock = None\n        self._started = Event()\n        self._is_stopped = False\n        self._initialized = True\n        # sys.stderr is not stored in the class like\n        # sys.exc_info since it can be changed between instances\n        self._stderr = _sys.stderr\n        # For debugging and _after_fork()\n        _dangling.add(self)\n\n    def _reset_internal_locks(self, is_alive):\n        # private!  Called by _after_fork() to reset our internal locks as\n        # they may be in an invalid state leading to a deadlock or crash.\n        self._started._reset_internal_locks()\n        if is_alive:\n            self._set_tstate_lock()\n        else:\n            # The thread isn't alive after fork: it doesn't have a tstate\n            # anymore.\n            self._is_stopped = True\n            self._tstate_lock = None\n\n    def __repr__(self):\n        assert self._initialized, \"Thread.__init__() was not called\"\n        status = \"initial\"\n        if self._started.is_set():\n            status = \"started\"\n        self.is_alive() # easy way to get ._is_stopped set when appropriate\n        if self._is_stopped:\n            status = \"stopped\"\n        if self._daemonic:\n            status += \" daemon\"\n        if self._ident is not None:\n            status += \" %s\" % self._ident\n        return \"<%s(%s, %s)>\" % (self.__class__.__name__, self._name, status)\n\n    def start(self):\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n        same thread object.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n            raise RuntimeError(\"threads can only be started once\")\n        with _active_limbo_lock:\n            _limbo[self] = self\n        try:\n            _start_new_thread(self._bootstrap, ())\n        except Exception:\n            with _active_limbo_lock:\n                del _limbo[self]\n            raise\n        self._started.wait()\n\n    def run(self):\n        \"\"\"Method representing the thread's activity.\n\n        You may override this method in a subclass. The standard run() method\n        invokes the callable object passed to the object's constructor as the\n        target argument, if any, with sequential and keyword arguments taken\n        from the args and kwargs arguments, respectively.\n\n        \"\"\"\n        try:\n            if self._target:\n                self._target(*self._args, **self._kwargs)\n        finally:\n            # Avoid a refcycle if the thread is running a function with\n            # an argument that has a member that points to the thread.\n            del self._target, self._args, self._kwargs\n\n    def _bootstrap(self):\n        # Wrapper around the real bootstrap code that ignores\n        # exceptions during interpreter cleanup.  Those typically\n        # happen when a daemon thread wakes up at an unfortunate\n        # moment, finds the world around it destroyed, and raises some\n        # random exception *** while trying to report the exception in\n        # _bootstrap_inner() below ***.  Those random exceptions\n        # don't help anybody, and they confuse users, so we suppress\n        # them.  We suppress them only when it appears that the world\n        # indeed has already been destroyed, so that exceptions in\n        # _bootstrap_inner() during normal business hours are properly\n        # reported.  Also, we only suppress them for daemonic threads;\n        # if a non-daemonic encounters this, something else is wrong.\n        try:\n            self._bootstrap_inner()\n        except:\n            if self._daemonic and _sys is None:\n                return\n            raise\n\n    def _set_ident(self):\n        self._ident = get_ident()\n\n    def _set_tstate_lock(self):\n        \"\"\"\n        Set a lock object which will be released by the interpreter when\n        the underlying thread state (see pystate.h) gets deleted.\n        \"\"\"\n        self._tstate_lock = _set_sentinel()\n        self._tstate_lock.acquire()\n\n    def _bootstrap_inner(self):\n        try:\n            self._set_ident()\n            self._set_tstate_lock()\n            self._started.set()\n            with _active_limbo_lock:\n                _active[self._ident] = self\n                del _limbo[self]\n\n            if _trace_hook:\n                _sys.settrace(_trace_hook)\n            if _profile_hook:\n                _sys.setprofile(_profile_hook)\n\n            try:\n                self.run()\n            except SystemExit:\n                pass\n            except:\n                # If sys.stderr is no more (most likely from interpreter\n                # shutdown) use self._stderr.  Otherwise still use sys (as in\n                # _sys) in case sys.stderr was redefined since the creation of\n                # self.\n                if _sys and _sys.stderr is not None:\n                    print(\"Exception in thread %s:\\n%s\" %\n                          (self.name, _format_exc()), file=_sys.stderr)\n                elif self._stderr is not None:\n                    # Do the best job possible w/o a huge amt. of code to\n                    # approximate a traceback (code ideas from\n                    # Lib/traceback.py)\n                    exc_type, exc_value, exc_tb = self._exc_info()\n                    try:\n                        print((\n                            \"Exception in thread \" + self.name +\n                            \" (most likely raised during interpreter shutdown):\"), file=self._stderr)\n                        print((\n                            \"Traceback (most recent call last):\"), file=self._stderr)\n                        while exc_tb:\n                            print((\n                                '  File \"%s\", line %s, in %s' %\n                                (exc_tb.tb_frame.f_code.co_filename,\n                                    exc_tb.tb_lineno,\n                                    exc_tb.tb_frame.f_code.co_name)), file=self._stderr)\n                            exc_tb = exc_tb.tb_next\n                        print((\"%s: %s\" % (exc_type, exc_value)), file=self._stderr)\n                    # Make sure that exc_tb gets deleted since it is a memory\n                    # hog; deleting everything else is just for thoroughness\n                    finally:\n                        del exc_type, exc_value, exc_tb\n            finally:\n                # Prevent a race in\n                # test_threading.test_no_refcycle_through_target when\n                # the exception keeps the target alive past when we\n                # assert that it's dead.\n                #XXX self._exc_clear()\n                pass\n        finally:\n            with _active_limbo_lock:\n                try:\n                    # We don't call self._delete() because it also\n                    # grabs _active_limbo_lock.\n                    del _active[get_ident()]\n                except:\n                    pass\n\n    def _stop(self):\n        # After calling ._stop(), .is_alive() returns False and .join() returns\n        # immediately.  ._tstate_lock must be released before calling ._stop().\n        #\n        # Normal case:  C code at the end of the thread's life\n        # (release_sentinel in _threadmodule.c) releases ._tstate_lock, and\n        # that's detected by our ._wait_for_tstate_lock(), called by .join()\n        # and .is_alive().  Any number of threads _may_ call ._stop()\n        # simultaneously (for example, if multiple threads are blocked in\n        # .join() calls), and they're not serialized.  That's harmless -\n        # they'll just make redundant rebindings of ._is_stopped and\n        # ._tstate_lock.  Obscure:  we rebind ._tstate_lock last so that the\n        # \"assert self._is_stopped\" in ._wait_for_tstate_lock() always works\n        # (the assert is executed only if ._tstate_lock is None).\n        #\n        # Special case:  _main_thread releases ._tstate_lock via this\n        # module's _shutdown() function.\n        lock = self._tstate_lock\n        if lock is not None:\n            assert not lock.locked()\n        self._is_stopped = True\n        self._tstate_lock = None\n\n    def _delete(self):\n        \"Remove current thread from the dict of currently running threads.\"\n\n        # Notes about running with _dummy_thread:\n        #\n        # Must take care to not raise an exception if _dummy_thread is being\n        # used (and thus this module is being used as an instance of\n        # dummy_threading).  _dummy_thread.get_ident() always returns -1 since\n        # there is only one thread if _dummy_thread is being used.  Thus\n        # len(_active) is always <= 1 here, and any Thread instance created\n        # overwrites the (if any) thread currently registered in _active.\n        #\n        # An instance of _MainThread is always created by 'threading'.  This\n        # gets overwritten the instant an instance of Thread is created; both\n        # threads return -1 from _dummy_thread.get_ident() and thus have the\n        # same key in the dict.  So when the _MainThread instance created by\n        # 'threading' tries to clean itself up when atexit calls this method\n        # it gets a KeyError if another Thread instance was created.\n        #\n        # This all means that KeyError from trying to delete something from\n        # _active if dummy_threading is being used is a red herring.  But\n        # since it isn't if dummy_threading is *not* being used then don't\n        # hide the exception.\n\n        try:\n            with _active_limbo_lock:\n                del _active[get_ident()]\n                # There must not be any python code between the previous line\n                # and after the lock is released.  Otherwise a tracing function\n                # could try to acquire the lock again in the same thread, (in\n                # current_thread()), and would block.\n        except KeyError:\n            if 'dummy_threading' not in _sys.modules:\n                raise\n\n    def join(self, timeout=None):\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n        called terminates -- either normally or through an unhandled exception\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof). As join() always returns None, you must call\n        isAlive() after join() to decide whether a timeout happened -- if the\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n        thread as that would cause a deadlock. It is also an error to join() a\n        thread before it has been started and attempts to do so raises the same\n        exception.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if not self._started.is_set():\n            raise RuntimeError(\"cannot join thread before it is started\")\n        if self is current_thread():\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n            self._wait_for_tstate_lock()\n        else:\n            # the behavior of a negative timeout isn't documented, but\n            # historically .join(timeout=x) for x<0 has acted as if timeout=0\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n\n    def _wait_for_tstate_lock(self, block=True, timeout=-1):\n        # Issue #18808: wait for the thread state to be gone.\n        # At the end of the thread's life, after all knowledge of the thread\n        # is removed from C data structures, C code releases our _tstate_lock.\n        # This method passes its arguments to _tstate_lock.acquire().\n        # If the lock is acquired, the C code is done, and self._stop() is\n        # called.  That sets ._is_stopped to True, and ._tstate_lock to None.\n        lock = self._tstate_lock\n        if lock is None:  # already determined that the C code is done\n            assert self._is_stopped\n        elif lock.acquire(block, timeout):\n            lock.release()\n            self._stop()\n\n    @property\n    def name(self):\n        \"\"\"A string used for identification purposes only.\n\n        It has no semantics. Multiple threads may be given the same name. The\n        initial name is set by the constructor.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert self._initialized, \"Thread.__init__() not called\"\n        self._name = str(name)\n\n    @property\n    def ident(self):\n        \"\"\"Thread identifier of this thread or None if it has not been started.\n\n        This is a nonzero integer. See the get_ident() function. Thread\n        identifiers may be recycled when a thread exits and another thread is\n        created. The identifier is available even after the thread has exited.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._ident\n\n    def is_alive(self):\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n        after the run() method terminates. The module function enumerate()\n        returns a list of all alive threads.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        if self._is_stopped or not self._started.is_set():\n            return False\n        self._wait_for_tstate_lock(False)\n        return not self._is_stopped\n\n    isAlive = is_alive\n\n    @property\n    def daemon(self):\n        \"\"\"A boolean value indicating whether this thread is a daemon thread.\n\n        This must be set before start() is called, otherwise RuntimeError is\n        raised. Its initial value is inherited from the creating thread; the\n        main thread is not a daemon thread and therefore all threads created in\n        the main thread default to daemon = False.\n\n        The entire Python program exits when no alive non-daemon threads are\n        left.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._daemonic\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if self._started.is_set():\n            raise RuntimeError(\"cannot set daemon status of active thread\")\n        self._daemonic = daemonic\n\n    def isDaemon(self):\n        return self.daemon\n\n    def setDaemon(self, daemonic):\n        self.daemon = daemonic\n\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n# The timer class was contributed by Itamar Shtull-Trauring\n\nclass Timer(Thread):\n    \"\"\"Call a function after a specified number of seconds:\n\n            t = Timer(30.0, f, args=None, kwargs=None)\n            t.start()\n            t.cancel()     # stop the timer's action if it's still waiting\n\n    \"\"\"\n\n    def __init__(self, interval, function, args=None, kwargs=None):\n        Thread.__init__(self)\n        self.interval = interval\n        self.function = function\n        self.args = args if args is not None else []\n        self.kwargs = kwargs if kwargs is not None else {}\n        self.finished = Event()\n\n    def cancel(self):\n        \"\"\"Stop the timer if it hasn't finished yet.\"\"\"\n        self.finished.set()\n\n    def run(self):\n        self.finished.wait(self.interval)\n        if not self.finished.is_set():\n            self.function(*self.args, **self.kwargs)\n        self.finished.set()\n\n\n# Special thread class to represent the main thread\n\nclass _MainThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=\"MainThread\", daemon=False)\n        self._set_tstate_lock()\n        self._started.set()\n        self._set_ident()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n\n# Dummy thread class to represent threads not started here.\n# These aren't garbage collected when they die, nor can they be waited for.\n# If they invoke anything in threading.py that calls current_thread(), they\n# leave an entry in the _active dict forever after.\n# Their purpose is to return *something* from current_thread().\n# They are marked as daemon threads so we won't wait for them\n# when we exit (conform previous semantics).\n\nclass _DummyThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=_newname(\"Dummy-%d\"), daemon=True)\n\n        self._started.set()\n        self._set_ident()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n    def _stop(self):\n        pass\n\n    def is_alive(self):\n        assert not self._is_stopped and self._started.is_set()\n        return True\n\n    def join(self, timeout=None):\n        assert False, \"cannot join a dummy thread\"\n\n\n# Global API functions\n\ndef current_thread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    If the caller's thread of control was not created through the threading\n    module, a dummy thread object with limited functionality is returned.\n\n    \"\"\"\n    try:\n        return _active[get_ident()]\n    except KeyError:\n        return _DummyThread()\n\ncurrentThread = current_thread\n\ndef active_count():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    The returned count is equal to the length of the list returned by\n    enumerate().\n\n    \"\"\"\n    with _active_limbo_lock:\n        return len(_active) + len(_limbo)\n\nactiveCount = active_count\n\ndef _enumerate():\n    # Same as enumerate(), but without the lock. Internal use only.\n    return list(_active.values()) + list(_limbo.values())\n\ndef enumerate():\n    \"\"\"Return a list of all Thread objects currently alive.\n\n    The list includes daemonic threads, dummy thread objects created by\n    current_thread(), and the main thread. It excludes terminated threads and\n    threads that have not yet been started.\n\n    \"\"\"\n    with _active_limbo_lock:\n        return list(_active.values()) + list(_limbo.values())\n\nfrom _thread import stack_size\n\n# Create the main thread object,\n# and make it available for the interpreter\n# (Py_Main) as threading._shutdown.\n\n_main_thread = _MainThread()\n\ndef _shutdown():\n    # Obscure:  other threads may be waiting to join _main_thread.  That's\n    # dubious, but some code does it.  We can't wait for C code to release\n    # the main thread's tstate_lock - that won't happen until the interpreter\n    # is nearly dead.  So we release it here.  Note that just calling _stop()\n    # isn't enough:  other threads may already be waiting on _tstate_lock.\n    tlock = _main_thread._tstate_lock\n    # The main thread isn't finished yet, so its thread state lock can't have\n    # been released.\n    assert tlock is not None\n    assert tlock.locked()\n    tlock.release()\n    _main_thread._stop()\n    t = _pickSomeNonDaemonThread()\n    while t:\n        t.join()\n        t = _pickSomeNonDaemonThread()\n\ndef _pickSomeNonDaemonThread():\n    for t in enumerate():\n        if not t.daemon and t.is_alive():\n            return t\n    return None\n\ndef main_thread():\n    \"\"\"Return the main thread object.\n\n    In normal conditions, the main thread is the thread from which the\n    Python interpreter was started.\n    \"\"\"\n    return _main_thread\n\n# get thread-local implementation, either from the thread\n# module, or from the python fallback\n\ntry:\n    from _thread import _local as local\nexcept ImportError:\n    from _threading_local import local\n\n\ndef _after_fork():\n    # This function is called by Python/ceval.c:PyEval_ReInitThreads which\n    # is called from PyOS_AfterFork.  Here we cleanup threading module state\n    # that should not exist after a fork.\n\n    # Reset _active_limbo_lock, in case we forked while the lock was held\n    # by another (non-forked) thread.  http://bugs.python.org/issue874900\n    global _active_limbo_lock, _main_thread\n    _active_limbo_lock = _allocate_lock()\n\n    # fork() only copied the current thread; clear references to others.\n    new_active = {}\n    current = current_thread()\n    _main_thread = current\n    with _active_limbo_lock:\n        # Dangling thread instances must still have their locks reset,\n        # because someone may join() them.\n        threads = set(_enumerate())\n        threads.update(_dangling)\n        for thread in threads:\n            # Any lock/condition variable may be currently locked or in an\n            # invalid state, so we reinitialize them.\n            if thread is current:\n                # There is only one active thread. We reset the ident to\n                # its new value since it can have changed.\n                thread._reset_internal_locks(True)\n                ident = get_ident()\n                thread._ident = ident\n                new_active[ident] = thread\n            else:\n                # All the others are already stopped.\n                thread._reset_internal_locks(False)\n                thread._stop()\n\n        _limbo.clear()\n        _active.clear()\n        _active.update(new_active)\n        assert len(_active) == 1\n",1357],"/usr/lib/python3.6/_weakrefset.py":["# Access WeakSet through the weakref module.\n# This code is separated-out because it is needed\n# by abc.py to load everything else at startup.\n\nfrom _weakref import ref\n\n__all__ = ['WeakSet']\n\n\nclass _IterationGuard:\n    # This context manager registers itself in the current iterators of the\n    # weak container, such as to delay all removals until the context manager\n    # exits.\n    # This technique should be relatively thread-safe (since sets are).\n\n    def __init__(self, weakcontainer):\n        # Don't create cycles\n        self.weakcontainer = ref(weakcontainer)\n\n    def __enter__(self):\n        w = self.weakcontainer()\n        if w is not None:\n            w._iterating.add(self)\n        return self\n\n    def __exit__(self, e, t, b):\n        w = self.weakcontainer()\n        if w is not None:\n            s = w._iterating\n            s.remove(self)\n            if not s:\n                w._commit_removals()\n\n\nclass WeakSet:\n    def __init__(self, data=None):\n        self.data = set()\n        def _remove(item, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(item)\n                else:\n                    self.data.discard(item)\n        self._remove = _remove\n        # A list of keys to be removed\n        self._pending_removals = []\n        self._iterating = set()\n        if data is not None:\n            self.update(data)\n\n    def _commit_removals(self):\n        l = self._pending_removals\n        discard = self.data.discard\n        while l:\n            discard(l.pop())\n\n    def __iter__(self):\n        with _IterationGuard(self):\n            for itemref in self.data:\n                item = itemref()\n                if item is not None:\n                    # Caveat: the iterator will keep a strong reference to\n                    # `item` until it is resumed or closed.\n                    yield item\n\n    def __len__(self):\n        return len(self.data) - len(self._pending_removals)\n\n    def __contains__(self, item):\n        try:\n            wr = ref(item)\n        except TypeError:\n            return False\n        return wr in self.data\n\n    def __reduce__(self):\n        return (self.__class__, (list(self),),\n                getattr(self, '__dict__', None))\n\n    def add(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.add(ref(item, self._remove))\n\n    def clear(self):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.clear()\n\n    def copy(self):\n        return self.__class__(self)\n\n    def pop(self):\n        if self._pending_removals:\n            self._commit_removals()\n        while True:\n            try:\n                itemref = self.data.pop()\n            except KeyError:\n                raise KeyError('pop from empty WeakSet')\n            item = itemref()\n            if item is not None:\n                return item\n\n    def remove(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.remove(ref(item))\n\n    def discard(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.discard(ref(item))\n\n    def update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        for element in other:\n            self.add(element)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def difference(self, other):\n        newset = self.copy()\n        newset.difference_update(other)\n        return newset\n    __sub__ = difference\n\n    def difference_update(self, other):\n        self.__isub__(other)\n    def __isub__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.difference_update(ref(item) for item in other)\n        return self\n\n    def intersection(self, other):\n        return self.__class__(item for item in other if item in self)\n    __and__ = intersection\n\n    def intersection_update(self, other):\n        self.__iand__(other)\n    def __iand__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.intersection_update(ref(item) for item in other)\n        return self\n\n    def issubset(self, other):\n        return self.data.issubset(ref(item) for item in other)\n    __le__ = issubset\n\n    def __lt__(self, other):\n        return self.data < set(ref(item) for item in other)\n\n    def issuperset(self, other):\n        return self.data.issuperset(ref(item) for item in other)\n    __ge__ = issuperset\n\n    def __gt__(self, other):\n        return self.data > set(ref(item) for item in other)\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.data == set(ref(item) for item in other)\n\n    def symmetric_difference(self, other):\n        newset = self.copy()\n        newset.symmetric_difference_update(other)\n        return newset\n    __xor__ = symmetric_difference\n\n    def symmetric_difference_update(self, other):\n        self.__ixor__(other)\n    def __ixor__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.symmetric_difference_update(ref(item, self._remove) for item in other)\n        return self\n\n    def union(self, other):\n        return self.__class__(e for s in (self, other) for e in s)\n    __or__ = union\n\n    def isdisjoint(self, other):\n        return len(self.intersection(other)) == 0\n",196],"example/src/multithread.py":["import os\nimport threading\nimport time\nfrom viztracer import VizTracer\n\n\ndef fib(n):\n    if n < 2:\n        return 1\n    time.sleep(0.0000001)\n    return fib(n - 1) + fib(n - 2)\n\n\nclass MyThread(threading.Thread):\n    def run(self):\n        fib(7)\n\n\nwith VizTracer(output_file=os.path.join(os.path.dirname(__file__), \"../\", \"json/multithread.json\"),\n               file_info=True) as _:\n    thread1 = MyThread()\n    thread2 = MyThread()\n    thread3 = MyThread()\n    thread4 = MyThread()\n\n    thread1.start()\n    thread2.start()\n    thread3.start()\n    thread4.start()\n\n    threads = [thread1, thread2, thread3, thread4]\n\n    for thread in threads:\n        thread.join()\n",34]},"functions":{"_newname (/usr/lib/python3.6/threading.py:727)":["/usr/lib/python3.6/threading.py",727],"current_thread (/usr/lib/python3.6/threading.py:1230)":["/usr/lib/python3.6/threading.py",1230],"daemon (/usr/lib/python3.6/threading.py:1120)":["/usr/lib/python3.6/threading.py",1120],"__init__ (/usr/lib/python3.6/threading.py:215)":["/usr/lib/python3.6/threading.py",215],"__init__ (/usr/lib/python3.6/threading.py:498)":["/usr/lib/python3.6/threading.py",498],"add (/usr/lib/python3.6/_weakrefset.py:81)":["/usr/lib/python3.6/_weakrefset.py",81],"__init__ (/usr/lib/python3.6/threading.py:757)":["/usr/lib/python3.6/threading.py",757],"is_set (/usr/lib/python3.6/threading.py:506)":["/usr/lib/python3.6/threading.py",506],"__enter__ (/usr/lib/python3.6/threading.py:239)":["/usr/lib/python3.6/threading.py",239],"_is_owned (/usr/lib/python3.6/threading.py:254)":["/usr/lib/python3.6/threading.py",254],"_release_save (/usr/lib/python3.6/threading.py:248)":["/usr/lib/python3.6/threading.py",248],"_acquire_restore (/usr/lib/python3.6/threading.py:251)":["/usr/lib/python3.6/threading.py",251],"wait (/usr/lib/python3.6/threading.py:263)":["/usr/lib/python3.6/threading.py",263],"__exit__ (/usr/lib/python3.6/threading.py:242)":["/usr/lib/python3.6/threading.py",242],"wait (/usr/lib/python3.6/threading.py:533)":["/usr/lib/python3.6/threading.py",533],"start (/usr/lib/python3.6/threading.py:828)":["/usr/lib/python3.6/threading.py",828],"fib (example/src/multithread.py:7)":["example/src/multithread.py",7],"run (example/src/multithread.py:15)":["example/src/multithread.py",15],"_stop (/usr/lib/python3.6/threading.py:966)":["/usr/lib/python3.6/threading.py",966],"_wait_for_tstate_lock (/usr/lib/python3.6/threading.py:1062)":["/usr/lib/python3.6/threading.py",1062],"join (/usr/lib/python3.6/threading.py:1024)":["/usr/lib/python3.6/threading.py",1024]}}}