{"version":3,"file":"service_worker.js","sources":["../../../out/ui/src/service_worker/service_worker.ts"],"sourcesContent":["// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This script handles the caching of the UI resources, allowing it to work\n// offline (as long as the UI site has been visited at least once).\n// Design doc: http://go/perfetto-offline.\n\n// When a new version of the UI is released (e.g. v1 -> v2), the following\n// happens on the next visit:\n// 1. The v1 (old) service worker is activated. At this point we don't know yet\n//    that v2 is released.\n// 2. /index.html is requested. The SW intercepts the request and serves it from\n//    the network.\n// 3a If the request fails (offline / server unreachable) or times out, the old\n//    v1 is served.\n// 3b If the request succeeds, the browser receives the index.html for v2. That\n//    will try to fetch resources from /v2/frontend_bundle.ts.\n// 4. When the SW sees the /v2/ request, will have a cache miss and will issue\n//    a network fetch(), returning the fresh /v2/ content.\n// 4. The v2 site will call serviceWorker.register('service_worker.js?v=v2').\n//    This (i.e. the different querystring) will cause a re-installation of the\n//    service worker (even if the service_worker.js script itself is unchanged).\n// 5. In the \"install\" step, the service_worker.js script will fetch the newer\n//    version (v2).\n//    Note: the v2 will be fetched twice, once upon the first request that\n//    causes causes a cache-miss, the second time while re-installing the SW.\n//    The  latter though will hit a HTTP 304 (Not Changed) and will be served\n//    from the browser cache after the revalidation request.\n// 6. The 'activate' handler is triggered. The old v1 cache is deleted at this\n//    point.\n\ndeclare let self: ServiceWorkerGlobalScope;\nexport {};\n\nconst LOG_TAG = `ServiceWorker: `;\nconst CACHE_NAME = 'ui-perfetto-dev';\n\n// If the fetch() for the / doesn't respond within 3s, return a cached version.\n// This is to avoid that a user waits too much if on a flaky network.\nconst INDEX_TIMEOUT_MS = 3000;\n\n// Use more relaxed timeouts when caching the subresources for the new version\n// in the background.\nconst INSTALL_TIMEOUT_MS = 30000;\n\n// The install() event is fired:\n// 1. On the first visit, when there is no SW installed.\n// 2. Every time the user opens the site and the version has been updated (they\n//    will get the newer version regardless, unless we hit INDEX_TIMEOUT_MS).\n// The latter happens because:\n// - / (index.html) is always served from the network (% timeout) and it pulls\n//   /v1.2-sha/frontend_bundle.js.\n// - /v1.2-sha/frontend_bundle.js will register /service_worker.js?v=v1.2-sha.\n// The service_worker.js script itself never changes, but the browser\n// re-installs it because the version in the V? query-string argument changes.\n// The reinstallation will cache the new files from the v.1.2-sha/manifest.json.\nself.addEventListener('install', (event) => {\n  const doInstall = async () => {\n    // If we can not access the cache we must give up on the service\n    // worker:\n    let bypass = true;\n    try {\n      bypass = await caches.has('BYPASS_SERVICE_WORKER');\n    } catch (_) {\n      // TODO(288483453)\n    }\n    if (bypass) {\n      // Throw will prevent the installation.\n      throw new Error(LOG_TAG + 'skipping installation, bypass enabled');\n    }\n\n    // Delete old cache entries from the pre-feb-2021 service worker.\n    try {\n      for (const key of await caches.keys()) {\n        if (key.startsWith('dist-')) {\n          await caches.delete(key);\n        }\n      }\n    } catch (_) {\n      // TODO(288483453)\n      // It's desirable to delete the old entries but it's not actually\n      // damaging to keep them around so don't give up on the\n      // installation if this fails.\n    }\n\n    // The UI should register this as service_worker.js?v=v1.2-sha. Extract the\n    // version number and pre-fetch all the contents for the version.\n    const match = /\\bv=([\\w.-]*)/.exec(location.search);\n    if (!match) {\n      throw new Error(\n          'Failed to install. Was epecting a query string like ' +\n          `?v=v1.2-sha query string, got \"${location.search}\" instead`);\n    }\n    await installAppVersionIntoCache(match[1]);\n\n    // skipWaiting() still waits for the install to be complete. Without this\n    // call, the new version would be activated only when all tabs are closed.\n    // Instead, we ask to activate it immediately. This is safe because the\n    // subresources are versioned (e.g. /v1.2-sha/frontend_bundle.js). Even if\n    // there is an old UI tab opened while we activate() a newer version, the\n    // activate() would just cause cache-misses, hence fetch from the network,\n    // for the old tab.\n    self.skipWaiting();\n  };\n  event.waitUntil(doInstall());\n});\n\nself.addEventListener('activate', (event) => {\n  console.info(LOG_TAG + 'activated');\n  const doActivate = async () => {\n    // This makes a difference only for the very first load, when no service\n    // worker is present. In all the other cases the skipWaiting() will hot-swap\n    // the active service worker anyways.\n    await self.clients.claim();\n  };\n  event.waitUntil(doActivate());\n});\n\nself.addEventListener('fetch', (event) => {\n  // The early return here will cause the browser to fall back on standard\n  // network-based fetch.\n  if (!shouldHandleHttpRequest(event.request)) {\n    console.debug(LOG_TAG + `serving ${event.request.url} from network`);\n    return;\n  }\n\n  event.respondWith(handleHttpRequest(event.request));\n});\n\n\nfunction shouldHandleHttpRequest(req: Request): boolean {\n  // Suppress warning: 'only-if-cached' can be set only with 'same-origin' mode.\n  // This seems to be a chromium bug. An internal code search suggests this is a\n  // socially acceptable workaround.\n  if (req.cache === 'only-if-cached' && req.mode !== 'same-origin') {\n    return false;\n  }\n\n  const url = new URL(req.url);\n  if (url.pathname === '/live_reload') return false;\n  return req.method === 'GET' && url.origin === self.location.origin;\n}\n\nasync function handleHttpRequest(req: Request): Promise<Response> {\n  if (!shouldHandleHttpRequest(req)) {\n    throw new Error(LOG_TAG + `${req.url} shouldn't have been handled`);\n  }\n\n  // We serve from the cache even if req.cache == 'no-cache'. It's a bit\n  // contra-intuitive but it's the most consistent option. If the user hits the\n  // reload button*, the browser requests the \"/\" index with a 'no-cache' fetch.\n  // However all the other resources (css, js, ...) are requested with a\n  // 'default' fetch (this is just how Chrome works, it's not us). If we bypass\n  // the service worker cache when we get a 'no-cache' request, we can end up in\n  // an inconsistent state where the index.html is more recent than the other\n  // resources, which is undesirable.\n  // * Only Ctrl+R. Ctrl+Shift+R will always bypass service-worker for all the\n  // requests (index.html and the rest) made in that tab.\n\n  const cacheOps = {cacheName: CACHE_NAME} as CacheQueryOptions;\n  const url = new URL(req.url);\n  if (url.pathname === '/') {\n    try {\n      console.debug(LOG_TAG + `Fetching live ${req.url}`);\n      // The await bleow is needed to fall through in case of an exception.\n      return await fetchWithTimeout(req, INDEX_TIMEOUT_MS);\n    } catch (err) {\n      console.warn(LOG_TAG + `Failed to fetch ${req.url}, using cache.`, err);\n      // Fall through the code below.\n    }\n  } else if (url.pathname === '/offline') {\n    // Escape hatch to force serving the offline version without attempting the\n    // network fetch.\n    const cachedRes = await caches.match(new Request('/'), cacheOps);\n    if (cachedRes) return cachedRes;\n  }\n\n  const cachedRes = await caches.match(req, cacheOps);\n  if (cachedRes) {\n    console.debug(LOG_TAG + `serving ${req.url} from cache`);\n    return cachedRes;\n  }\n\n  // In any other case, just propagate the fetch on the network, which is the\n  // safe behavior.\n  console.warn(LOG_TAG + `cache miss on ${req.url}, using live network`);\n  return fetch(req);\n}\n\nasync function installAppVersionIntoCache(version: string) {\n  const manifestUrl = `${version}/manifest.json`;\n  try {\n    console.log(LOG_TAG + `Starting installation of ${manifestUrl}`);\n    await caches.delete(CACHE_NAME);\n    const resp = await fetchWithTimeout(manifestUrl, INSTALL_TIMEOUT_MS);\n    const manifest = await resp.json();\n    const manifestResources = manifest['resources'];\n    if (!manifestResources || !(manifestResources instanceof Object)) {\n      throw new Error(`Invalid manifest ${manifestUrl} : ${manifest}`);\n    }\n\n    const cache = await caches.open(CACHE_NAME);\n    const urlsToCache: RequestInfo[] = [];\n\n    // We use cache:reload to make sure that the index is always current and we\n    // don't end up in some cycle where we keep re-caching the index coming from\n    // the service worker itself.\n    urlsToCache.push(new Request('/', {cache: 'reload', mode: 'same-origin'}));\n\n    for (const [resource, integrity] of Object.entries(manifestResources)) {\n      // We use cache: no-cache rather then reload here because the versioned\n      // sub-resources are expected to be immutable and should never be\n      // ambiguous. A revalidation request is enough.\n      const reqOpts: RequestInit = {\n        cache: 'no-cache',\n        mode: 'same-origin',\n        integrity: `${integrity}`,\n      };\n      urlsToCache.push(new Request(`${version}/${resource}`, reqOpts));\n    }\n    await cache.addAll(urlsToCache);\n    console.log(LOG_TAG + 'installation completed for ' + version);\n  } catch (err) {\n    console.error(LOG_TAG + `Installation failed for ${manifestUrl}`, err);\n    await caches.delete(CACHE_NAME);\n    throw err;\n  }\n}\n\nfunction fetchWithTimeout(req: Request|string, timeoutMs: number) {\n  const url = (req as {url?: string}).url || `${req}`;\n  return new Promise<Response>((resolve, reject) => {\n    const timerId = setTimeout(() => {\n      reject(new Error(`Timed out while fetching ${url}`));\n    }, timeoutMs);\n    fetch(req).then((resp) => {\n      clearTimeout(timerId);\n      if (resp.ok) {\n        resolve(resp);\n      } else {\n        reject(new Error(\n            `Fetch failed for ${url}: ${resp.status} ${resp.statusText}`));\n      }\n    }, reject);\n  });\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAiCA,MAAM,OAAO,GAAG,CAAA,eAAA,CAAiB,CAAC;AAClC,MAAM,UAAU,GAAG,iBAAiB,CAAC;AAErC;AACA;AACA,MAAM,gBAAgB,GAAG,IAAI,CAAC;AAE9B;AACA;AACA,MAAM,kBAAkB,GAAG,KAAK,CAAC;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CAAC,gBAAgB,CAAC,SAAS,EAAE,CAAC,KAAK,KAAI;AACzC,IAAA,MAAM,SAAS,GAAG,YAAW;;;QAG3B,IAAI,MAAM,GAAG,IAAI,CAAC;QAClB,IAAI;YACF,MAAM,GAAG,MAAM,MAAM,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;AACpD,SAAA;AAAC,QAAA,OAAO,CAAC,EAAE;;AAEX,SAAA;AACD,QAAA,IAAI,MAAM,EAAE;;AAEV,YAAA,MAAM,IAAI,KAAK,CAAC,OAAO,GAAG,uCAAuC,CAAC,CAAC;AACpE,SAAA;;QAGD,IAAI;YACF,KAAK,MAAM,GAAG,IAAI,MAAM,MAAM,CAAC,IAAI,EAAE,EAAE;AACrC,gBAAA,IAAI,GAAG,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;AAC3B,oBAAA,MAAM,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC1B,iBAAA;AACF,aAAA;AACF,SAAA;AAAC,QAAA,OAAO,CAAC,EAAE;;;;;AAKX,SAAA;;;QAID,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QACpD,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,KAAK,CACX,sDAAsD;AACtD,gBAAA,CAAA,+BAAA,EAAkC,QAAQ,CAAC,MAAM,CAAA,SAAA,CAAW,CAAC,CAAC;AACnE,SAAA;AACD,QAAA,MAAM,0BAA0B,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;;;;;;;QAS3C,IAAI,CAAC,WAAW,EAAE,CAAC;AACrB,KAAC,CAAC;AACF,IAAA,KAAK,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC,CAAC;AAC/B,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,CAAC,KAAK,KAAI;AAC1C,IAAA,OAAO,CAAC,IAAI,CAAC,OAAO,GAAG,WAAW,CAAC,CAAC;AACpC,IAAA,MAAM,UAAU,GAAG,YAAW;;;;AAI5B,QAAA,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;AAC7B,KAAC,CAAC;AACF,IAAA,KAAK,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC,CAAC;AAChC,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC,KAAK,KAAI;;;AAGvC,IAAA,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;AAC3C,QAAA,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,CAAA,QAAA,EAAW,KAAK,CAAC,OAAO,CAAC,GAAG,CAAA,aAAA,CAAe,CAAC,CAAC;QACrE,OAAO;AACR,KAAA;IAED,KAAK,CAAC,WAAW,CAAC,iBAAiB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC,CAAC;AAGH,SAAS,uBAAuB,CAAC,GAAY,EAAA;;;;IAI3C,IAAI,GAAG,CAAC,KAAK,KAAK,gBAAgB,IAAI,GAAG,CAAC,IAAI,KAAK,aAAa,EAAE;AAChE,QAAA,OAAO,KAAK,CAAC;AACd,KAAA;IAED,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAC7B,IAAA,IAAI,GAAG,CAAC,QAAQ,KAAK,cAAc;AAAE,QAAA,OAAO,KAAK,CAAC;AAClD,IAAA,OAAO,GAAG,CAAC,MAAM,KAAK,KAAK,IAAI,GAAG,CAAC,MAAM,KAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;AACrE,CAAC;AAED,eAAe,iBAAiB,CAAC,GAAY,EAAA;AAC3C,IAAA,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,EAAE;QACjC,MAAM,IAAI,KAAK,CAAC,OAAO,GAAG,CAAG,EAAA,GAAG,CAAC,GAAG,CAA8B,4BAAA,CAAA,CAAC,CAAC;AACrE,KAAA;;;;;;;;;;;AAaD,IAAA,MAAM,QAAQ,GAAG,EAAC,SAAS,EAAE,UAAU,EAAsB,CAAC;IAC9D,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAC7B,IAAA,IAAI,GAAG,CAAC,QAAQ,KAAK,GAAG,EAAE;QACxB,IAAI;YACF,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,CAAiB,cAAA,EAAA,GAAG,CAAC,GAAG,CAAE,CAAA,CAAC,CAAC;;AAEpD,YAAA,OAAO,MAAM,gBAAgB,CAAC,GAAG,EAAE,gBAAgB,CAAC,CAAC;AACtD,SAAA;AAAC,QAAA,OAAO,GAAG,EAAE;AACZ,YAAA,OAAO,CAAC,IAAI,CAAC,OAAO,GAAG,CAAA,gBAAA,EAAmB,GAAG,CAAC,GAAG,CAAA,cAAA,CAAgB,EAAE,GAAG,CAAC,CAAC;;AAEzE,SAAA;AACF,KAAA;AAAM,SAAA,IAAI,GAAG,CAAC,QAAQ,KAAK,UAAU,EAAE;;;AAGtC,QAAA,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE,QAAQ,CAAC,CAAC;AACjE,QAAA,IAAI,SAAS;AAAE,YAAA,OAAO,SAAS,CAAC;AACjC,KAAA;IAED,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AACpD,IAAA,IAAI,SAAS,EAAE;QACb,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,CAAW,QAAA,EAAA,GAAG,CAAC,GAAG,CAAa,WAAA,CAAA,CAAC,CAAC;AACzD,QAAA,OAAO,SAAS,CAAC;AAClB,KAAA;;;IAID,OAAO,CAAC,IAAI,CAAC,OAAO,GAAG,CAAiB,cAAA,EAAA,GAAG,CAAC,GAAG,CAAsB,oBAAA,CAAA,CAAC,CAAC;AACvE,IAAA,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AACpB,CAAC;AAED,eAAe,0BAA0B,CAAC,OAAe,EAAA;AACvD,IAAA,MAAM,WAAW,GAAG,CAAG,EAAA,OAAO,gBAAgB,CAAC;IAC/C,IAAI;QACF,OAAO,CAAC,GAAG,CAAC,OAAO,GAAG,CAA4B,yBAAA,EAAA,WAAW,CAAE,CAAA,CAAC,CAAC;AACjE,QAAA,MAAM,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QAChC,MAAM,IAAI,GAAG,MAAM,gBAAgB,CAAC,WAAW,EAAE,kBAAkB,CAAC,CAAC;AACrE,QAAA,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AACnC,QAAA,MAAM,iBAAiB,GAAG,QAAQ,CAAC,WAAW,CAAC,CAAC;QAChD,IAAI,CAAC,iBAAiB,IAAI,EAAE,iBAAiB,YAAY,MAAM,CAAC,EAAE;YAChE,MAAM,IAAI,KAAK,CAAC,CAAA,iBAAA,EAAoB,WAAW,CAAM,GAAA,EAAA,QAAQ,CAAE,CAAA,CAAC,CAAC;AAClE,SAAA;QAED,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC5C,MAAM,WAAW,GAAkB,EAAE,CAAC;;;;AAKtC,QAAA,WAAW,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,GAAG,EAAE,EAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,aAAa,EAAC,CAAC,CAAC,CAAC;AAE3E,QAAA,KAAK,MAAM,CAAC,QAAQ,EAAE,SAAS,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,EAAE;;;;AAIrE,YAAA,MAAM,OAAO,GAAgB;AAC3B,gBAAA,KAAK,EAAE,UAAU;AACjB,gBAAA,IAAI,EAAE,aAAa;gBACnB,SAAS,EAAE,CAAG,EAAA,SAAS,CAAE,CAAA;aAC1B,CAAC;AACF,YAAA,WAAW,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,CAAA,EAAG,OAAO,CAAA,CAAA,EAAI,QAAQ,CAAE,CAAA,EAAE,OAAO,CAAC,CAAC,CAAC;AAClE,SAAA;AACD,QAAA,MAAM,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAChC,OAAO,CAAC,GAAG,CAAC,OAAO,GAAG,6BAA6B,GAAG,OAAO,CAAC,CAAC;AAChE,KAAA;AAAC,IAAA,OAAO,GAAG,EAAE;QACZ,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,CAA2B,wBAAA,EAAA,WAAW,CAAE,CAAA,EAAE,GAAG,CAAC,CAAC;AACvE,QAAA,MAAM,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;AAChC,QAAA,MAAM,GAAG,CAAC;AACX,KAAA;AACH,CAAC;AAED,SAAS,gBAAgB,CAAC,GAAmB,EAAE,SAAiB,EAAA;IAC9D,MAAM,GAAG,GAAI,GAAsB,CAAC,GAAG,IAAI,CAAA,EAAG,GAAG,CAAA,CAAE,CAAC;IACpD,OAAO,IAAI,OAAO,CAAW,CAAC,OAAO,EAAE,MAAM,KAAI;AAC/C,QAAA,MAAM,OAAO,GAAG,UAAU,CAAC,MAAK;YAC9B,MAAM,CAAC,IAAI,KAAK,CAAC,4BAA4B,GAAG,CAAA,CAAE,CAAC,CAAC,CAAC;SACtD,EAAE,SAAS,CAAC,CAAC;QACd,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAI;YACvB,YAAY,CAAC,OAAO,CAAC,CAAC;YACtB,IAAI,IAAI,CAAC,EAAE,EAAE;gBACX,OAAO,CAAC,IAAI,CAAC,CAAC;AACf,aAAA;AAAM,iBAAA;AACL,gBAAA,MAAM,CAAC,IAAI,KAAK,CACZ,CAAA,iBAAA,EAAoB,GAAG,CAAK,EAAA,EAAA,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,CAAE,CAAA,CAAC,CAAC,CAAC;AACpE,aAAA;SACF,EAAE,MAAM,CAAC,CAAC;AACb,KAAC,CAAC,CAAC;AACL;;;;;;;;"}